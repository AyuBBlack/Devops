Что нужно сделать:
> 1. Написать еще 2 джобы в вашем .gitlab-ci.yaml 
> 2. Первая джоба должна собирать ваш проект в deb-пакет и выкладывать его в качестве артефакта
> 3. Вторая джоба должна подхватывать деб-пакет, собранный в предыдущем этапе и создать docker-образ, в котором будет установленный с помощью вытянутого деб-пакета проект
> 4. (под звездочкой, не обязательно) за основу скриптов дебки возьмите мой репозиторий, с намеренными ошибками и исправьте их, чтоб все работало. Опишите найденные ошибки (их как минимум 4)
> 

Для начала я сразу приступил к пункту 4. 

Переделал control:

```
Package: SqlBundle
Version: 1.0.1
Section: misc
Architecture: all
Maintainer: Ayub Black
Description: My api 

```


Потом передалал остальные скрипты
К примеру, этом он завершался с кодом 1 при повторной установке, ибо exit 1 было не в самом внизу, где собственно он должен выходить с ошибкой во всех остальных случаях. 


```
echo "========== Preinstall started =========="
case "$1" in
install)
    echo "===== preinst install ====="
    ;;

upgrade)
    echo "===== preinst upgrade ====="
    ;;

abort-upgrade)
    echo "===== preinst abort upgrade ====="
    ;;

*)
    echo "===== preinst called with unknown argument '$1' =====" >&2
    exit 1
    ;;
esac

echo "------ Preinstall success ------"
```
Примерно такие же мелкие ошибки исправил в остальных скриптах, опять тот же ololo, который вообще не к месту там лежал)

Далее я скачал свой проект запаковал его в деб и проверил, что всё работает. 

![](https://i.imgur.com/024kxxq.png)

Так, теперь можно и приступить к самим джобам.

Для начала нужно было, чтобы сделать билд деб пакета, сделал я это в разделе скрипт:

`script: dpkg-deb --build . myapp.deb`

Потом передал это в артефактах 


```
stages:      
  - build
  - build-docker

build-deb:
  stage: build
  script: dpkg-deb --build . myapp.deb
  artifacts:
    paths:
      - ./myapp.deb
  tags:
    - "dev"
       
```
На этапе билда докер файл я сначала получаю по умолчанию получаю артефакты, т.к. это новый стэйдж. После чего делаю 

`dpkg --extract myapp.deb .` который распаковывает файл в из дэб пакет в текущей директории.

Ну и дальше как обычно делаю докербилд из докерфайл, который был в дэб пакете.


```
build-docker:   
  stage: build-docker   
  script:
    - dpkg --extract myapp.deb .
    - docker build -t ayub95/repo . 
  tags:
    - "dev"
```

У этого варианта есть маленький недочет в плане проверки того, что точно ли образ собирается из того, что нам распаколвал наш deb, посему сделал еще отдельный вариант, где точно можно узнать, что оно работает так, как надо.


```
build-deb:
  stage: build
  script: 
    - dpkg-deb --build . myapp.deb
    - ls -l
  artifacts:
    paths:
      - ./myapp.deb
  tags:
    - "dev"

build-docker:   
  stage: build-docker   
  script:
    - if [ -d ~/deb ]; then echo "ok"; else mkdir ~/deb; fi;
    - dpkg --extract myapp.deb ~/deb
    - ls -l
    - docker build -t ayub95/repo ~/deb/ 
    - ls -l
  tags:
    - "dev"
```

Этот вариант отличается тем, что я распаковываю мой deb пакет в директорию deb, следовательно после чего я докер образ собираю из этой директории, чтобы не было путаницы. 